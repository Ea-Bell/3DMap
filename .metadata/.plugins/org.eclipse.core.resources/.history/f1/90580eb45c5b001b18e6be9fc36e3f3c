/**
 * 전역변수
 * rows: 엑셀 컨트롤 변수 
 */
var map; // 맵의 접근 가능;
var Start= function Component(){	
	const kakaoMapcomponent = new KakaoMapcomponent();	
	kakaoMapcomponent.StartMap();	
}

 class KakaoMapcomponent {
	 
	constructor() {
	}
	StartMap(){
		var container = document.getElementById('map');
		var options = {
			center: new kakao.maps.LatLng(38.21440383, 128.4376055),
			level: 3
		};		
		 map = new kakao.maps.Map(container, options);		
	}
	
	ExcelMap(markerPosition){
		let ExcelLenghs= num; //이 변수가 필요한지에 대한 논의 후 결정하시오.
						
	/* 테스트용 코드
	 * MakerPosition[][]
		console.log(markerPosition[0]['Position']['La']);
		console.log(markerPosition[1]['Position']['Ma']);
		console.log(markerPosition[2]['Position']);
		console.log(markerPosition[3]['Position']);
		console.log(markerPosition[4]['Position']);
	* 결과: 잘나옴.
	*/	
		/*클릭 리스너임
		ClickListener();
		*/		
		
		let Imgsrc= $("#img").attr("src");
		let WebGL='<div id="WebGL-output">';
		console.log(Imgsrc);
		const kakao = new KakaoMapcomponent(); 
		/*kakao.MultiMarker(Imgsrc, markerPosition);*/
		kakao.CustomMarker(WebGL);
	}
	
	
	//마크 표시할때 요기서 값을 넘겨 받아서 쓸것.
	MultiMarker(Imgsrc, markerPosition){
		//마커 100개 표시
		for(let i =0 ; i<100; i++){
			let imageSize = new kakao.maps.Size(24, 35);
			let markerImage= new kakao.maps.MarkerImage(Imgsrc, imageSize);			
		 let marker = new kakao.maps.Marker({
		        map: map, // 마커를 표시할 지도
		        position: markerPosition[i].latlng, // 마커를 표시할 위치	        
		        image : markerImage // 마커 이미지 
		    });		 
		}
	}
	
	CustomMarker(WebGL){
		var customOverlay = new kakao.maps.CustomOverlay({
		    position: new kakao.maps.LatLng(38.21440383, 128.4376055),
		    content: WebGL 
		});
	
		customOverlay.setMap(map);
		debugger
		Object3d();
	}
	
	
	/**
	 *Parameters:
	 * MyPosition: 현재 내 위치배열(x,y)값
	 * DestinationPosition: 다음 지점 까지의배열 (x,y)값
	 * return: Number;
	 */
	getAngle (MyPosition, DestinationPosition) {
		/**
		 *	  변수목록
		 *    px1: 내위치의x값
		 *    px2: 다음 지점의 x값
		 *    py1: 내위치의 y값
		 *    py2: 다음 지점의 y값
		 *    x  : px2-px1
		 *    y  : py2-py2
		 *      
		 *    radian:     
		 *    degree: 방향값
		 **/		
		const px1=0, py1=0;
		 let px2=-2, py2=-2;
		 const PI=Math.PI;
		 	
		 let x = px2-px1;
		 let y = py2-py1;

		 let radian = Math.atan2(y, x);
		 let degree= radian*180/PI;
		 return degree; 
	}
}
 
 function Object3d() {

     var stats = initStats();

     // create a scene, that will hold all our elements                        such as objects, cameras and lights.
     var scene = new THREE.Scene();

     // create a camera, which defines where we're looking at.
     var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);

     // create a render and set the size
     var webGLRenderer = new THREE.WebGLRenderer();
    webGLRenderer.setClearColor(0xffffff,0.5);
     webGLRenderer.setSize(350, 350);
     webGLRenderer.shadowMapEnabled = true;

     // position and point the camera to the center of the scene
     // 차량의 회전은 z축이 담당한다.
     
     camera.position.x = 0;
     camera.position.y = 90;
     camera.position.z = 0;
     
     camera.rotation.x= -90;
     camera.rotation.y= 0;
     camera.rotation.z= 0;
     
     camera.lookAt(scene.position);
     scene.add(camera);

     
     // add spotlight for the shadows
     var spotLight = new THREE.DirectionalLight(0xffffff);
     spotLight.position.set(10, 10, 10);
     spotLight.intensity = 1;
     scene.add(spotLight);

     // add the output of the renderer to the html element
     document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);

     // call the render function
     var step = 0;


     // setup the control gui
     var controls = new function () {
         // we need the first child, since it's a multimaterial

     };

     var mesh;
		var pineconeobj='/Frontend/script/libs/assets/models/pinecone.obj';
		var carobj='/Frontend/3DObj/carmodeltest.obj';
     var loader = new THREE.OBJLoader();
     loader.load(carobj, function (loadedMesh) {
        /* var material = new THREE.MeshLambertMaterial({color: 0x5C3A21});*/
    	 var material = new THREE.MeshBasicMaterial({map: texture});
    	 
         // loadedMesh is a group of meshes. For
         // each mesh set the material, and compute the information
         // three.js needs for rendering.
         loadedMesh.children.forEach(function (child) {
             child.material = material;
             child.geometry.computeFaceNormals();
             child.geometry.computeVertexNormals();
           
         });

         mesh = loadedMesh;
         loadedMesh.scale.set(1, 1, 1);
         
         loadedMesh.position.x=0;
         loadedMesh.position.y=0;
         loadedMesh.position.z=0;
         
         
         loadedMesh.rotation.x =0;
         loadedMesh.rotation.y =(90+0)*(Math.PI/180);//요기에 변환하는 리턴 함수를 만들어서 각도를 변한 할 수 있게 만드시오.
         console.log(loadedMesh.rotation.y);
         loadedMesh.rotation.z =0;
         
         textyre= new THREE.Texture(map);
         
         
         scene.add(mesh);
     });

     render()


    function render() {
         stats.update();

        if (mesh) {
             mesh.rotation.y += 0;
             mesh.rotation.x += 0;
//             mesh.rotation.y+=0.006;
         } 


         // render using requestAnimationFrame
          requestAnimationFrame(render); 
         webGLRenderer.render(scene, camera);
     } 

     function initStats() {

         var stats = new Stats();
         stats.setMode(0); // 0: fps, 1: ms

         // Align top-left
         stats.domElement.style.position = 'absolute';
         stats.domElement.style.left = '0px';
         stats.domElement.style.top = '0px';

       /* document.getElementById("Stats-output").appendChild(stats.domElement);*/

         return stats;
     } 
 }
 
 
 //시작함수.
 Start();
